# Ибрагимова Алина Александровна, БПИ226, дз8 (С++).

## Условие:
![изображение](https://github.com/AlinaMalinafff/AVS/assets/150148650/5a66f9bc-f094-413a-81fd-e989c7d36186)
![изображение](https://github.com/AlinaMalinafff/AVS/assets/150148650/a3c0ea45-48f5-49b4-8dff-528fdd79f56e)


## Состав загруженного решения:
Задание сделано на критерии 9-10 баллов.

В файлах hw8_avs_4threads и hw8_avs_1thread находятся файлы с проектами на 8 баллов: в первом проект, где задание выполняется с помощью 4ёх потоков; во втором проект с однопоточным выполнением.

В файле 9-10 лежит общий проект на вычисление по формуле через разное количество потоков и разное количество элементов в векторе.

В файле отчётная_таблица на первом листе приведена таблица на 8 баллов, на втором листе таблица с рассчётами времени на 9-10 баллов.


## Предупреждение:
В тексте задания числом элементов вектора фигурирует число 10 миллионов, в то время как в таблице, которую надо дозаполнить, фигурирует 100 миллионов. Я взяла именно 10 миллионов, чтоб в блоке критериев на 9-10 ярче была разница, как помогает многопоточность с увеличением количества данных.
![изображение](https://github.com/AlinaMalinafff/AVS/assets/150148650/1c7e6418-ae82-4f02-a1be-47ec493cf5e7)
![изображение](https://github.com/AlinaMalinafff/AVS/assets/150148650/ebf83743-c134-48ab-9a93-6c3718063e4d)



## Разбор проекта hw8_avs_1thread:
Сначала решила честно идти через векторы, создавая и заполняя их согласно условию. Программу писала по образцу программы из семинара 17: сделала глобальным константными переменными количество потоков, размер векторов и собственно сами векторы; далее определила стартовую функцию func для дочерних потоков, вычисляющую по приведённой в задании формуле результат; и далее в main описала менеджмент потоков: создала массивы с тредами и с номерами тредов, включила счётчик времени, в цикле определила элементы массива номеров тредов значениями, тут же создавая потоки через pthread_create, далее по очереди через цикл реализовала менеджмент потоков через pthread_join (ожидаем завершение выполнения потока, включаем следующий), остановила таймер, посчитала разницу между включением таймера и его остановкой и вывела полученные данные(значение формулы на векторах и время выполнения) на консоль.

Пример вывода:
![изображение](https://github.com/AlinaMalinafff/AVS/assets/150148650/0ad3cb4e-f8af-4be5-b858-0275148363ef)


## Разбор проекта hw8_avs_1thread:
Так как в прошлой программе я реализовала функционал, чтобы создавать и запускать не только один поток, а сразу несколько (у меня потоки создаются через цикл, даже если их 1 штука), поэтому единственное, что пришлось поменять - это значение глобальной переменной, отвечающей за количество потоков. В файле "отчётная_таблица.эксель" на первом листе я отразила, какие значение получались с использованием 4 потоков и созданием отдельных векторов для А и В. Между использованием одного потока и 4 не было ощутимой разницы, поэтому я решила поэкспериментировать и сделать реализацию без отдельных векторов для А и В (как раз эта версия проекта и загружена сюда). Так как оба вектора заполняются элементами в зависимости от их порядкого номера в векторе, рассчёт по формуле было легко реализовать через цикл, оперируя порядковыми элементами. Количество затраченного времени резко понизилось, как видно из таблицы "отчётная_таблица.эксель".

## Разбор проекта 9-10:
Я решилась попробовать применить размер вектора 500000000 и один поток в программе с созданием отдельных векторов А и В, но решила бросить эту затею, когда время выполнения программы превысило 90к. Использовала программу без реализации векторов. На таких больших данных как раз и проявилась полезность многопоточности: минимальные временные затраты (можно так же отследить по таблице "отчётная_таблица.эксель") были замечены на 8 потоках, при этом резутаты 1000 потоков были хуже - чем-то это коррелирует с законом убывающей полезности в микроэкономике.

## Свопинг
Свопинг - ситуация, когда объём памяти для хранения данных больше, чем оперативная память компьютера - тогда происходит использование памяти подкачки: ОС начинает использовать файл подкачки на жёстком диске, предлагая ему хранить невлезающие данные. Это создаёт задержки, т.к. данные из файла нужно получить, и это время - из оперативной памяти они достаются быстрее. 

Таким образом, свопинг можно заприметить, когда время работы программы увеличивается при изменении (в нашем случае!) количества элементов в векторе или количества потоков.

Я думаю, свопинг происходит, когда количество потоков становится слишком большим на больших количествах элементов, таких как 500000000 и 100000000000. Например, по таблице это прослеживается при 1000 потоках - время становится значительно больше, чем при 8 потоках.

Спасибо за внимание!
![2968941ed5deb007127c35093a358c98](https://github.com/AlinaMalinafff/AVS/assets/150148650/a956df72-0f46-42ca-8453-7af4cc981f7e)

